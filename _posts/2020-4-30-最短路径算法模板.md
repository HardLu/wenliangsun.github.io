---
layout: post
title: "最短路径算法模板"
subtitle: "最短路径"
author: WenlSun"
header-style: text
tag:
  - 算法模板
---
我们只需考虑有向图上的算法，因为无向图是特殊的有向图。我们可以将所有无向边 `u↔vu↔v`，都拆分成两条有向边：`u←vu←v` 和 `u→vu→v`。为了方便叙述，我们做如下约定：$n$ 表示图中点数，$m$ 表示图中边数。[参考yxc大佬的分享](最短路算法模板)

## 图的存储

图的存储方法一般有两种方式：

+ 邻接矩阵：开个二维数组，`g[i][j]`表示点$i$和点$j$之间的边权。
+ 邻接表：邻接表有两种常用写法，推荐第二种，代码更简洁，效率也更高，后面有代码模板：
(1) 二维vector：`vector<vector<int>> edge`，`edge[i][j]` 表示第 $i$ 个点的第 $j$ 条邻边。
(2) 数组模拟邻接表：为每个点开个单链表，分别存储该点的所有邻边。

## 最短路径算法

最短路径分为两大类：

+ 单源最短路径：常用的算法有：(1)dijkstra 只有所有边的权值为正时才可以使用。在稠密图上时间复杂度是$O(n^2)$,在稀疏图上的时间复杂度是$O(mlogn)$。(2)spfa 不论边权是正还是负，都可以做。算法平均时间复杂度是$O(km)$,推荐使用该算法。
+ 多源最短路径：一般用floyd算法，代码很短，三重循环，时间复杂度是$O(n^3)$

## Dijkstra算法

给一张无向图，n 个点 m 条边，求从1号点到 n 号点的最短路径。输入中可能包含重边。

### C++ 版本模板

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 2000010, INF = 1000000000;

int n, m;
int g[N][N], dist[N];   // g[][]存储图的邻接矩阵, dist[]表示每个点到起点的最短距离
bool st[N];     // 存储每个点的最短距离是否已确定

void dijkstra(){
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    for (int i = 0; i < n; i++){
        int id, mind = INF;
        for (int j = 1; j <= n; j++)
            if (!st[j] && dist[j] < mind){
                mind = dist[j];
                id = j;
            }
        st[id] = 1;
        for (int j = 1; j <= n; j++) dist[j] = min(dist[j], dist[id] + g[id][j]);
    }
}

int main(){
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            g[i][j] = INF;
    for (int i = 0; i < m; i++){
        int a, b, c; // 边a-b 以及 权重 c
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    dijkstra();
    cout << dist[n] << endl;
    return 0;
}
```