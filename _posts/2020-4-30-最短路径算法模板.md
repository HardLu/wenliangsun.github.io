---
layout: post
title: "最短路径算法模板"
subtitle: "最短路径"
author: WenlSun"
header-style: text
tag:
  - 算法模板
---
我们只需**考虑有向图上的算法，因为无向图是特殊的有向图**。我们可以将所有无向边 `u↔vu↔v`，都拆分成两条有向边：`u←vu←v` 和 `u→vu→v`。为了方便叙述，我们做如下约定：$n$ 表示图中点数，$m$ 表示图中边数。[参考yxc大佬的分享](最短路算法模板)

## 图的存储

图的存储方法一般有两种方式：

+ 邻接矩阵：开个二维数组，`g[i][j]`表示点$i$和点$j$之间的边权。
+ 邻接表：邻接表有两种常用写法，推荐第二种，代码更简洁，效率也更高，后面有代码模板：
(1) 二维vector：`vector<vector<int>> edge`，`edge[i][j]` 表示第 $i$ 个点的第 $j$ 条邻边。
(2) 数组模拟邻接表：为每个点开个单链表，分别存储该点的所有邻边。

## 最短路径算法

最短路径分为两大类：

+ 单源最短路径：常用的算法有：(1)dijkstra 只有所有边的权值为正时才可以使用。在稠密图上时间复杂度是$O(n^2)$,在稀疏图上的时间复杂度是$O(mlogn)$。(2)spfa 不论边权是正还是负，都可以做。算法平均时间复杂度是$O(km)$,推荐使用该算法。
+ 多源最短路径：一般用floyd算法，代码很短，三重循环，时间复杂度是$O(n^3)$

## Dijkstra算法

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

输入： 第一行包含整数n和m。接下来m行每行包含三个整数a，b，c，表示存在一条从点a到点b的有向边，边长为c。

输出：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出-1。

样例：<br>3 3<br>1 2 2<br>2 3 1<br>1 3 4<br> 输出 3

### C++ 版本模板

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 2000010, INF = 1000000000;

int n, m;
int g[N][N], dist[N];   // g[][]存储图的邻接矩阵, dist[]表示每个点到起点的最短距离
bool st[N];     // 用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新

void dijkstra(){
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    for (int i = 0; i < n; i++){
        int id, mind = INF;
        // 每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点
        // 该步骤即寻找还未确定最短路的点中路径最短的点
        for (int j = 1; j <= n; j++)
            if (!st[j] && dist[j] < mind){
                mind = dist[j];
                id = j;
            }
        //id 代表就是剩余未确定最短路的点中 路径最短的点 而与此同时该点的最短路径也已经确定我们将该点标记
        st[id] = 1;
        // 然后用这个去更新其余未确定点的最短距离
        //这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离
        //但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响
        //当然你也可以在循环判断条件里加上if(!st[i])
        //这里j从1开始只是为了代码的简洁
        for (int j = 1; j <= n; j++) dist[j] = min(dist[j], dist[id] + g[id][j]);
    }
}

int main(){
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            g[i][j] = INF;
    for (int i = 0; i < m; i++){
        int a, b, c; // 边a-b 以及权重
        cin >> a >> b >> c;
        // 去重边
        g[a][b] = min(g[a][b], c);
        // 去重边，若是无向图则将无向图转为有向图 ，注意题目中的要求
        // g[a][b] = g[b][a] = min(g[a][b], c);
    }
    dijkstra();
    if (dis[n] == INF)
        cout << -1 << endl;
    else
        cout << dis[n] << endl;
    return 0;
}
```

